# Полезная информация по коллекциям в Java
Для того, чтобы хранить множество каких-то данных в одном объекте – нужно использовать массив. Массивы очень полезная вещь в мире Java, однако у нее есть недостатки, например, фиксированная длина и в них нельзя хранить объекты в виде стека, очередей, дерева, поэтому вместо массивов есть возможность использовать коллекции.

## 1. Интерфейс Collection, класс Collections и иерархия коллекций в Java
**Collection** – базовый интерфейс для всех коллекций, расширяет интерфейс Iterable. Содержит методы добавления/удаления элемента в коллекцию (add/remove), добавления/удаления объектов одной коллекции в другую (addAll/removeAll/retain - кроме тех, которые есть в коллекции), очистки коллекции (clear), сравнения (contains), получения количества элементов (size), преобразования коллекции в массив (toArray). При помощи Iterator’а можно пробегаться по всем элементам коллекции и взаимодействовать с ними.

**Collections** - класс, предназначенный для работы с коллекциями. Содержит в себе стандартные методы для сортировки коллекции в алфавитном порядке/компаратора (sort), перемешивания коллекции (shuffle), реверса (reverse), копирования (copy), превращения в потокобезопасную коллекцию (synchronizedCollection) и получения числа вхождений указанного объекта в коллекцию (frequency).

## 2. Очереди
**Queue** – интерфейс, расширяющий интерфейс Collection и Iterable. Данные хранятся в виде однонаправленной очереди. Элементы коллекции хранятся в упорядоченном виде **F**irst **I**n **F**irst **O**ut (в виде обычной очереди).

**Deque** – интерфейс, расширяющий интерфейс Queue. Данные хранятся в виде двунаправленных очередей. То есть можно взаимодействовать с элементами сразу в двух направлениях – **F**irst **I**n **F**irst **O**ut (в виде обычной очереди) или же Last In First Out (в виде стека).

**ArrayDeque** – класс, реализующий интерфейс Deque, соответственно, является двунаправленной очередью. Количество элементов растет по мере необходимости. Начальная емкость с обычным конструктором 16 элементов или же можно задать свою. Можно взаимодействовать с элементами (добавлять/изменять/удалять) в двух направлениях – ***FIFO (обычная очередь)***, ***LIFO (стек)***. Не является потокобезопасным. Для многопоточного приложения лучше использовать ArrayBlockingQueue. **Быстрее, чем LinkedList и Stack.**

**PriorityQueue** – класс, реализующий интерфейс Queue, соответственно, является однонаправленной очередью. Элементы располагаются в естественном порядке или же могут быть отсортированы при помощи компаратора. Объекты обрабатываются в очереди, основанной на приоритете. Нельзя добавлять null-значения и не сравниваемые объекты. Размер неограничен, он также расширяется при добавлении элементов. Не является потокобезопасным. Для многопоточного приложения лучше использовать PriorityBlockingQueue.

## 3. Списки
**List** – интерфейс простого списка, расширяющий интерфейс Collection. Есть стандартные методы по типу add, addAll, get, set и другие.

**ArrayList** – представляет собой «массив в виде коллекции» - элементы идут по порядку. К элементам списка можно обращаться по индексам. Нумерация элементов начинается с 0. Если мы хотим добавить элемент в середину, то все элементы, которые находятся после него придется сдвигать и только потом уже добавлять этот элемент в список. Удаление работает примерно по такому же принципу. Взятие и изменение элемента в списке происходит быстро, так как мы напрямую обращаемся к нужному элементу массива.

**Алгоритм добавления элемента в ArrayList:**
1. Проверка, есть ли место в списке
2. Если место достаточно, то элемент добавляется в конец списка.
3. Если места недостаточно, ArrayList будет расширен при помощи
метода ensureCapacity(minCapacity), по формуле: (oldCapacity * 3) / 2 + 1, также происходит копирование элементов при помощи System.arrayCopy(). Потом уже добавляется элемент.

**Алгоритм удаления элемента в ArrayList:**
1. Определяется количество элементов, которое надо скопировать
2. Происходит копирование элементов при помощи System.arrayCopy() 3. Уменьшается размер массива и последний элемент удаляется
LinkedList – представляет собой связный список. Каждый элемент в нем хранит в себе ссылку на предыдущий и следующий элемент и соответственно ему требуется больше памяти для работы, чем тому же ArrayList’у. Если мы хотим добавить элемент в середину, то нам достаточно всего лишь поменять ссылки рядом стоящих элементов. Удаление работает также – поменять ссылки на элементы намного быстрее. Взятие и изменение элемента в списке происходит медленно, так как мы последовательно проходимся по всем элементам.

**Алгоритм добавления элемента в LinkedList:**
1. Создается Entry-объект, который содержит в себе добавляемый элемент, header (имеет указатели на следующий и предыдущий элемент списка, если список пуст – указывают сами на себя), и ссылку header.prev.
2. Указатели на предыдущий и следующий элемент переопределяются и размер списка увеличивается.

**Алгоритм удаления элемента в LinkedList:**
1. Ищется элемент с указанным значением
2. Указатели предыдущего и следующего элемента переопределяются. 3. Указатели на предыдущий и следующий элемент null-ятся и размер
списка уменьшается.

**Вопрос: Что лучше использовать?**
**Ответ:** Зависит от ситуации. Если нужно добавлять/удалять элементы с разными индексами в любое место списка (в середину, например), то однозначно стоит использовать LinkedList – он на порядок быстрее ArrayList. Однако стоит помнить, что так как он хранит в себе ссылки на предыдущий и следующий элементы, то и памяти ему нужно на это больше. В других случаях стоит использовать ArrayList. Добавление элементов в конец у них происходит быстро.

**Vector** – представляет собой массив с динамически меняющимся размером. Является потокобезопасным и медленным. Сейчас редко используется из-за того, что неактуален. Начальный размер 10 при стандартном конструкторе. В конструкторе ему также можно задать размер и значение, на которое будет увеличиваться количество элементов при заполнении. Можно копировать, получать первый/последний элементы.

**Stack** – представляет собой подкласс Vector’a. Содержит в себе все методы вектора. Реализует стек - Last In First Out (последний зашел – первый вышел). Стек можно сравнить с расположением товаров в магазине – тот товар, который продавец положил последним – будет лежать самым первым перед покупателем, покупатель – возьмет его. Есть методы pop() (возвращает и удаляет элемент) – снять со стека, и push (добавляет и возвращает добавленный элемент) – положить на стек. Также можно получить вершину стека при помощи метода peek() – элемент при этом не будет удален или же выполнить поиск по стеку методом search(Object), который вернет смещение от вершины стека.

Также хотелось отметить наличие у списков собственного итератора – ListIterator. У Iterator есть метод next, при помощи которого можно переходить к следующей итерации при переборе элементов коллекции, в ListIterator помимо этого метода есть еще метод previous, который позволяет нам переходить к предыдущей итерации. Также ListIterator можно добавлять/удалять элементы методами add/remove.

## 4. Множества
**Set** – интерфейс простого множества, расширяющий интерфейс Collection. Представляет собой множество из уникальных элементов. Разные реализации этого интерфейса могут использовать разный порядок хранения элементов.

**HashSet** – представляет собой хеш-таблицу, в которой все элементы коллекции хранятся в виде хеш-кода. Расположение элементов по мере добавления произвольное, оно может меняться. Можно задавать начальный размер и коэффициент загрузки (на сколько должна быть заполнена таблица, чтобы пришлось ее расширить). Когда мы достигаем максимального количества элементов, размер хеш-таблицы удваивается. Можно создавать либо пустое множество, либо множество из коллекции. По элементам коллекции можно проходиться при помощи итератора. На уровне Java элементы добавляются в Map по хеш-коду. И да, null туда можно добавить :)

**LinkedHashSet** – представляет собой связанную хеш-таблицу, в которой все элементы коллекции хранятся в виде хеш-кода. Порядок элементов при добавлении элементов сохраняется, есть ссылки на следующий элемент. Параметры конструктора такие же, как у HashSet.

**TreeSet** – представляет собой отсортированное множество, которые хранится в виде красно-черного дерева. Если мы добавим в него несколько строк, они будут отсортированы в алфавитном порядке по возрастанию. Если мы хотим хранить в нем какие-то объекты, у них должен быть реализован метод compare для того, чтобы можно было бы сравнить элементы при добавлении, иначе вылетит Exception.

***Сравнение HashSet и TreeSet:***
HashSet быстрее, чем TreeSet. Так как TreeSet - отсортированное множество, хранящееся в виде красно-черного дерева, а элементы у HashSet представлены в виде хеш-таблицы. У TreeSet еще есть элементы first, last, headSet, tailSet, то есть можно получать первый/последний элемент и верхний/нижний.

## 5. Словари
 
**Map <Key, Value>** - интерфейс словаря, не расширяет интерфейс Collection, так как представляет собой другую структуру – «уникальный ключ, значение». При помощи словарей мы можем быстро получать/изменять/удалять значения, зная ключ. Среди методов есть containsKey, containsValue – при помощи которых можно узнать, содержится ли тот или иной ключ/значение в коллекции, также можно получать набор всех ключей/значений. Если попытаться добавить новое значение с уже существующим ключом – элемент коллекции попросту перезапишется.

**AbstractMap** – абстрактный класс, реализующий интерфейс Map.

**HashMap** – реализует интерфейс Map и наследуется от класса AbstractMap. Представляет собой хеш-таблицу, которая состоит из ключа, значения и хеш-кода объекта. Работает намного быстрее TreeMap. Является не синхронизированной и соответственное не потокобезопасной. Можно использовать ConcurentHashMap для работы с многопоточностью. Ее лучше всего использовать, если не нужна упорядоченность. Не допускается дублирование ключей, может хранить один-ключ null (при добавлении элемента будет просто вызываться метод putForNullKey), и множество значений null.

**Алгоритм добавления элемента в HashMap:**
1. Ключ проверяется на null, если true – putForNullKey()
2. Генерация hashCode на основе ключа
3. Вызывается метод indexFor(hash, tableLenght) для того, чтобы определить место, куда будет помещен добавляемый элемент.
4. Сравнивается хеш-код и ключ элемента. Если равны – элемент будет перезаписан.
5. Если не равны, элемент будет записан в коллекцию при помощи addEntry(hash, key, value, index) под указанным ключом.

***Удаление происходит похожим образом.***

При добавлении элементов может возникнуть **коллизия** (это когда у нас позиция в массиве получается такая, что там уже есть какой-то элемент), тогда новый элемент будет добавляться в начало цепочки.

**ConcurentHashMap** – является потокобезопасным аналогом HashMap.

**LinkedHashMap** – реализует интерфейс Map и расширяет класс HashMap. В отличие от HashMap сохраняет порядок, в котором добавлялись элементы.

**SortedMap** – реализует интерфейс Map. Элементы хранятся в отсортированном виде в порядке возрастания ключей. Можно получать ключ первого/последнего элемента.

**NavigableMap** – расширяет интерфейс SortedMap, есть возможность получать элементы с наибольшим/наименьшим ключом, сравнивать ключи и взаимодействовать с элементами отображения.

**TreeMap** – наследуется от AbstractMap и реализует интерфейс NavigableMap. Представляет собой отсортированное отображение, которые хранится в виде красно-черного дерева. Элементы коллекции сортируются по ключам в порядке возрастания. Можно добавить компаратор. Работает медленнее HashMap из-за сортировки при добавлении элементов.

**HashTable** – хеш-таблица, реализующая интерфейс Map. Является синхронизированной и потокобезопасной, соответственно медленнее, чем HashMap. В ней нельзя хранить null-ключи и null-значения.
